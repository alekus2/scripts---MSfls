import pandas as pd
import os
from datetime import datetime

class CadastroSGF:
    def verificar(self, paths):
        nomes_colunas = [
            "Id","Tipo Propriedade","Id Região","Região","Id Projeto","Projeto",
            "Localidade","Talhão","Ciclo","Rotação","Tipo","Feição Pai",
            "Descrição de Uso do Solo","Fase","Bacia","Solo","Relevo","Espaçamento",
            "Sistema de Propagação","Mat.Genético","Espécie","Data Plantio",
            "Mês de Plantio","Regime","Sítio","Área (ha)","Área GIS","Atualizar via GIS",
            "Distância Total","Tipo de Registro","Cód. Projeto Investimento",
            "Dcr. Projeto Investimento","Cód. Tarefa Proj. Invest.","Não tem",
            "Observações","DCAA Data Emissão","DCAA Data Validade","Início Vigência",
            "Fim Vigência","Distância Terra","Precipitação","Distância Asfalto",
            "Ciclo de Investimento","Área declivosa (%)","Tipo Contrato",
            "Projeto Expansão","DCAA Número","Não tem","Não tem","Regional Colheita",
            "Regional Silvicultura","Região Climática","Não tem","Bioma","Não tem",
            "Não tem","Registro","Ativo"
        ]

        meses = ["Janeiro","Fevereiro","Março","Abril","Maio","Junho",
                 "Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"]
        nome_mes = meses[datetime.now().month - 1]
        data_emissao = datetime.now().strftime("%Y%m%d")

        # --- monta pasta de saída (como antes) ---
        base_path = os.path.abspath(paths[0])
        if nome_mes.lower() in base_path.lower():
            parent_dir = os.path.dirname(base_path)
            pasta_output = parent_dir if os.path.basename(parent_dir).lower()=='output' \
                           else os.path.join(parent_dir,'output')
        else:
            base_dir = os.path.dirname(paths[0])
            pasta_mes = os.path.join(os.path.dirname(base_dir), nome_mes)
            pasta_output = os.path.join(pasta_mes, 'output')
        os.makedirs(pasta_output, exist_ok=True)

        for path in paths:
            if not os.path.exists(path):
                print(f"Erro: Arquivo '{path}' não encontrado.")
                continue
            print(f"Processando: {path}")
            df = pd.read_excel(path, sheet_name=0, header=1)
            colunas_faltando = []

            # Inicia DataFrame vazio
            df_reorganizado = pd.DataFrame(index=df.index)

            for col in nomes_colunas:
                if col in df.columns:
                    # insere coluna existente, mantendo índice
                    df_reorganizado.insert(len(df_reorganizado.columns), col, df[col].values)
                elif col == "Não tem":
                    # insere placeholder em branco, várias vezes
                    blank = pd.Series([""] * len(df), index=df.index)
                    df_reorganizado.insert(len(df_reorganizado.columns), col, blank)
                else:
                    # coluna ausente e não-placeholder
                    colunas_faltando.append(col)

            # salva sem colisão de nomes
            nome_base = f"SGF_{nome_mes}_{data_emissao}"
            contador = 1
            destino = lambda c: os.path.join(pasta_output, f"{c}_{str(contador).zfill(2)}.xlsx")
            novo_arquivo = destino(nome_base)
            while os.path.exists(novo_arquivo):
                contador += 1
                novo_arquivo = destino(nome_base)

            df_reorganizado.to_excel(novo_arquivo, index=False)
            print(f"✅ Dados reorganizados salvos em '{novo_arquivo}'.")
            if colunas_faltando:
                print("Colunas esperadas não encontradas na planilha original:")
                for c in colunas_faltando:
                    print(f"  - {c}")

# Exemplo de uso
cadastrar = CadastroSGF()
arquivos = [r"colocar/nome/aqui.xlsx"]
cadastrar.verificar(arquivos)


Processando: /content/export_lmanhaes_2025-05-07_09-09-01.xls.xlsx
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
<ipython-input-2-0eb19a31ebba> in <cell line: 0>()
     80 cadastrar = CadastroSGF()
     81 arquivos = [r"/content/export_lmanhaes_2025-05-07_09-09-01.xls.xlsx"]
---> 82 cadastrar.verificar(arquivos)

1 frames
/usr/local/lib/python3.11/dist-packages/pandas/core/frame.py in insert(self, loc, column, value, allow_duplicates)
   5156         if not allow_duplicates and column in self.columns:
   5157             # Should this be a different kind of error??
-> 5158             raise ValueError(f"cannot insert {column}, already exists")
   5159         if not is_integer(loc):
   5160             raise TypeError("loc must be int")

ValueError: cannot insert Não tem, already exists


a ordem tem que ser mantida, o codigo nao esta tentando duplicar colunas varias vezes repetidamente ne?
